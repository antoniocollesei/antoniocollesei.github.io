<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<h1 id="data-upload-and-inspection">Data Upload and Inspection</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>load("project_dataset.RData")

head(CCLE_MUT_CNA_AMP_DEL_binary_Revealer[,1:4])

##                  DMS53_LUNG SW1116_LARGE_INTESTINE NCIH1694_LUNG P3HR1_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE
## AKT3_MUT                  0                      0             0                                        0
## ABI1_MUT                  0                      0             0                                        0
## CDH2_MUT                  0                      0             0                                        0
## LOC100130776_MUT          0                      0             0                                        0
## HDAC6_MUT                 0                      0             0                                        0
## BCL2L11_MUT               0                      0             0                                        0
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;br&gt;</code> The <strong>CCLE_MUT_CNA_AMP_DEL_binary_Revealer</strong> file contains
mutations for each cell line, from the CCLE project. Each line
corresponds to a mutation (of various types) in a gene; for example
HDAC6_MUT indicates a single base mutation (MUT) in the HDAC6 gene.
Each column from the third corresponds to a cell line. An entry to 1
indicates that the mutation in that gene is present in the cell line,
while 0 indicates that the mutation is not present in the cell line.
More info about the project can be found here:
<a href="https://portals.broadinstitute.org/ccle/about" rel="external nofollow noopener" target="_blank">https://portals.broadinstitute.org/ccle/about</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target &lt;- target_data_NAcount_August21
row.names(target) &lt;- as.character(target[,1])
target &lt;- target[,-1]
head(target[,1:4])

##                   X22RV1_PROSTATE X2313287_STOMACH X42MGBA_CENTRAL_NERVOUS_SYSTEM X451LU_SKIN
## (5Z)-7-Oxozeaenol       0.8625642        0.7597489                      0.6585792   0.1044209
## 5-Fluorouracil          0.4865437        0.6063343                      0.7244520   0.9585177
## 681640                  0.9579365        0.9682534                      0.9476494         NaN
## A-443654                      NaN              NaN                            NaN         NaN
## A-770041                      NaN              NaN                            NaN         NaN
## Afatinib (1)            0.9808510        0.9815897                      0.9844018   0.9888358
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;br&gt;</code> The <strong>target_data_NAcount_August21</strong> file contains the response
of cell lines to various pharmacological compounds, from the GDSC
project. Each row corresponds to a compound; each column corresponds to
a cell line. The value of an entry is a measure of how much the cell
line responds to the drug compound. More info about the project can be
found here: <a href="https://www.cancerrxgene.org/" rel="external nofollow noopener" target="_blank">https://www.cancerrxgene.org/</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(readr)
pathways &lt;- read_delim("PathwayCommons12.panther.hgnc.txt",
            "\t", escape_double = FALSE,
            col_types = cols(INTERACTION_DATA_SOURCE = col_skip(),
            INTERACTION_PUBMED_ID = col_skip(),
            INTERACTION_TYPE = col_skip(), MEDIATOR_IDS = col_skip(),
            PATHWAY_NAMES = col_skip()), trim_ws = TRUE)
head(pathways)

## # A tibble: 6 × 2
##   PARTICIPANT_A PARTICIPANT_B
##`&lt;chr&gt;`         `&lt;chr&gt;`
## 1 ABAT          ALDH5A1
## 2 ABAT          ALDH6A1
## 3 ABAT          CSAD
## 4 ABAT          GAD1
## 5 ABAT          GAD2
## 6 ACHE          CHEBI:15354
</code></pre></div></div>

<p>The <strong>PathwayCommons12.panther.hgnc</strong> file contains all the gene-gene
interactions discovered so far; this is useful in order to smooth the
mutations matrix, which is extremely sparse. It has been downloaded from
<a href="https://www.pathwaycommons.org/" rel="external nofollow noopener" target="_blank">https://www.pathwaycommons.org/</a>.</p>

<h2 id="needed-packages">Needed Packages</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>suppressPackageStartupMessages({
conflictRules("DelayedArray", exclude = "seed")
library(NMF)
library(SummarizedExperiment)
library(netSmooth)
library(stringi)
library(stringr)
library(readr)
library(igraph)
library(tidyverse)
library(caret)
library(neuralnet)
library(plotly)
})
</code></pre></div></div>

<h1 id="mutations-matrix-smoothing">Mutations Matrix Smoothing</h1>

<p>The CCLE dataset sonsiders 48270 mutations: since the human genetic pool
consists of around 20000 genes, and each one can mutate in three
different ways (insertion, deletion, single-base mutation, the dataset
is involving almost every possible mutation (20k*3 = 60k). It is
necessary to select the most relevant mutations, because they exceed
enourmously the number of cell lines, having a strong impact on future
computations. The Non-Negative Matrix Factorization (NMF) is a powerful
tool to perform feature selection, but it works well with non-sparse
matrices.</p>

<p>The CCLE dataset appears to be extremely sparse, as it is possible to
appreciate from the following heatmap. Even though the size has been
reduced for computational reasons, the same situation can be extended to
the whole set.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>heatmap(as.matrix(CCLE_MUT_CNA_AMP_DEL_binary_Revealer[1:200, 1:200]))
</code></pre></div></div>

<p><img src="project_work_files/figure-markdown_strict/unnamed-chunk-5-1.png" alt=""></p>

<p>It may be useful to rename the matrices to make them more
“user-friendly” to handle</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutations &lt;- CCLE_MUT_CNA_AMP_DEL_binary_Revealer
drugs &lt;- target_data_NAcount_August21
</code></pre></div></div>

<p>It is important to work with comparable datasets, containing the same
cell lines: this will enable robust results in terms of model
construction. In the following lines of code, only common cell lines
will be kept, filtering out the uncommon.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tissues_CCLE &lt;- colnames(mutations)
tissues_CCLE &lt;- unique(gsub("[^_]*_(.*)", "\\1", tissues_CCLE))

tissues_GDSC &lt;- colnames(drugs)[-1]
tissues_GDSC &lt;- unique(gsub("[^_]*_(.*)", "\\1", tissues_GDSC))

# Which and how many different tissues are being considered?
(tissues &lt;- sort(intersect(tissues_CCLE, tissues_GDSC)))

##  [1] "AUTONOMIC_GANGLIA"                  "BILIARY_TRACT"                      "BONE"                               "BREAST"
##  [5] "CENTRAL_NERVOUS_SYSTEM"             "ENDOMETRIUM"                        "HAEMATOPOIETIC_AND_LYMPHOID_TISSUE" "KIDNEY"
##  [9] "LARGE_INTESTINE"                    "LIVER"                              "LUNG"                               "OESOPHAGUS"
## [13] "OVARY"                              "PANCREAS"                           "PLEURA"                             "PROSTATE"
## [17] "SKIN"                               "SMALL_INTESTINE"                    "SOFT_TISSUE"                        "STOMACH"
## [21] "THYROID"                            "UPPER_AERODIGESTIVE_TRACT"          "URINARY_TRACT"

k &lt;- length(tissues)

# Keeping only common cell lines
mutations &lt;- mutations[, grep(paste(tissues, sep = "", collapse = "|"), colnames(mutations))]
drugs &lt;- drugs[, grep(paste(tissues, sep = "", collapse = "|"), colnames(drugs))]
</code></pre></div></div>

<p>It is helpful to perform smoothing independently for mutations,
insertions and deletions: the Pathway Commons interaction database
considers gene-gene relationships and the smoothing algorithm (package
<em>netSmooth</em>) recognizes the gene names in the dataset with respect to
the adjacency matrix built on the interaction database itself. The
following process is meant to separate the datasets into three smaller
datasets, apply smoothing and then rebuild the original dataset, that
now will include the non-sparse information.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Creation of the three datasets based on the type of mutation
mutations_MUT &lt;- mutations[grep("_MUT", row.names(mutations)), ]
mutations_AMP &lt;- mutations[grep("_AMP", row.names(mutations)), ]
mutations_DEL &lt;- mutations[grep("_DEL", row.names(mutations)), ]

# Remove the subscripts from the lines of the matrices to be analyzed
row.names(mutations_MUT) &lt;- str_replace_all(row.names(mutations_MUT), "_MUT", "")
row.names(mutations_AMP) &lt;- str_replace_all(row.names(mutations_AMP), "_AMP", "")
row.names(mutations_DEL) &lt;- str_replace_all(row.names(mutations_DEL), "_DEL", "")

# Creating the Adjacency Matrix
adj &lt;- get.adjacency(graph.edgelist(as.matrix(pathways), directed=FALSE))

# Network smoothing
smoothed_MUT &lt;- netSmooth(as.matrix(mutations_MUT), adj, alpha=0.5)

## Using given alpha: 0.5

smoothed_AMP &lt;- netSmooth(as.matrix(mutations_AMP), adj, alpha=0.5)

## Using given alpha: 0.5

smoothed_DEL &lt;- netSmooth(as.matrix(mutations_DEL), adj, alpha=0.5)

## Using given alpha: 0.5

# Rebuild
row.names(smoothed_MUT) &lt;- paste0(row.names(smoothed_MUT), "_MUT", "")
row.names(smoothed_DEL) &lt;- paste0(row.names(smoothed_DEL), "_DEL", "")
row.names(smoothed_AMP) &lt;- paste0(row.names(smoothed_AMP), "_AMP", "")
mutations.smoothed &lt;- rbind(smoothed_MUT, smoothed_AMP, smoothed_DEL)

# If a mutation is not present in any cell line, you can remove it
# (it is also an NMF algorithm constraint)
mutations.smoothed &lt;- mutations.smoothed[apply(mutations.smoothed, 1, function(x) !all(x==0)),]
</code></pre></div></div>

<h1 id="cancer-targeted-feature-selection">Cancer-targeted Feature Selection</h1>

<p>The necessity of selecting the most relevant mutations has already been
acknowledged. As a plus, it can improve the specificity of the analysis
if each cancer type was considered independently. It should be worth
focusing on tumors highly represented in terms of cell lines: also a
“poorly-represented” cancer type will be included to check whether the
lower amount of data affects the performance of the model. First of all,
let’s check the number of cell lines per tumor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tissues_CCLE &lt;- colnames(mutations.smoothed)
tissues_CCLE &lt;- unique(gsub("[^_]*_(.*)", "\\1", tissues_CCLE))

tissues_occurrencies &lt;- c()
for (i in 1:length(tissues_CCLE)) {
  tmp &lt;- grep(tissues_CCLE[i], colnames(mutations.smoothed))
  tissues_occurrencies[i] &lt;- length(tmp)
  rm(tmp)
}
tissues_occurrencies &lt;- as.data.frame(t(tissues_occurrencies))
colnames(tissues_occurrencies) &lt;- tissues_CCLE

# Sort tissues_occurrencies data frame column-wise
sorted_tissues_occurrencies &lt;- tissues_occurrencies[, order(-apply(tissues_occurrencies, 2, sum))]

# Print the sorted data frame
print(sorted_tissues_occurrencies[1:5])

##   LUNG HAEMATOPOIETIC_AND_LYMPHOID_TISSUE CENTRAL_NERVOUS_SYSTEM SKIN LARGE_INTESTINE
## 1  185                                182                     68   61              59
</code></pre></div></div>

<p><em>Lung</em> and <em>Haematopoietic and Lymphoid Tissue</em> cancers will be included
in the analysis; also <em>Breast</em> cancer will be considered, due to its
clinical relevance, despite offering just one third of the data with
respect to the other two cancer types.</p>

<p>In the following lines of code, the most relevant mutations for these
three tumors will be extracted, once again through NMF and exploiting
its built-in function featureScore(). The value <strong>s</strong> stands for the
number of extracted mutations. <strong>k</strong> is the number of clusters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s &lt;- 250
k&lt;- 4

# LUNG --------------------------------------------------------------------

# Filtering out LUNG from data
mutations.smoothed_LUNG &lt;- mutations.smoothed[, grep("_LUNG", colnames(mutations.smoothed))]
mutations.smoothed_LUNG &lt;- mutations.smoothed_LUNG[apply(mutations.smoothed_LUNG, 1, function(x) !all(x==0)),]

# NMF
res_LUNG &lt;- nmf(mutations.smoothed_LUNG, k, 'lee', seed=123456)
mutation_score_LUNG &lt;- featureScore(res_LUNG)

# Feature selection
mutations_topscore_LUNG &lt;- sort(featureScore(res_LUNG), decreasing = T)[1:s]

# Filter the mutations matrix based on scores
index &lt;- c()
for (i in 1:length(mutations_topscore_LUNG)) {
  tmp &lt;- grep(paste0("^", names(mutations_topscore_LUNG[i]), "$"), row.names(mutations))
  if(length(tmp)&gt;1) cat(paste0(tmp, " "))
  index &lt;- c(index, tmp)
}

mutations.filtered_LUNG &lt;- mutations[index, grep("_LUNG", colnames(mutations))]

# HLT ---------------------------------------------------------------------

# Filtering out HLT from data
mutations.smoothed_HLT &lt;- mutations.smoothed[, grep("_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE", colnames(mutations.smoothed))]
mutations.smoothed_HLT &lt;- mutations.smoothed_HLT[apply(mutations.smoothed_HLT, 1, function(x) !all(x==0)),]

# NMF
res_HLT &lt;- nmf(mutations.smoothed_HLT, k, 'lee', seed=123456)
mutation_score_HLT &lt;- featureScore(res_HLT)

# Feature selection
mutations_topscore_HLT &lt;- sort(featureScore(res_HLT), decreasing = T)[1:s]

# Filter the mutations matrix based on scores
index &lt;- c()
for (i in 1:length(mutations_topscore_HLT)) {
  tmp &lt;- grep(paste0("^", names(mutations_topscore_HLT[i]), "$"), row.names(mutations))
  if(length(tmp)&gt;1) cat(paste0(tmp, " "))
  index &lt;- c(index, tmp)
}

mutations.filtered_HLT &lt;- mutations[index, grep("_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE", colnames(mutations))]

# BREAST ---------------------------------------------------------------------

# Filtering out BREAST from data
mutations.smoothed_BREAST &lt;- mutations.smoothed[, grep("_BREAST", colnames(mutations.smoothed))]
mutations.smoothed_BREAST &lt;- mutations.smoothed_BREAST[apply(mutations.smoothed_BREAST, 1, function(x) !all(x==0)),]

# NMF
res_BREAST &lt;- nmf(mutations.smoothed_BREAST, k, 'lee', seed=123456)
mutation_score_BREAST &lt;- featureScore(res_BREAST)

# Feature selection
mutations_topscore_BREAST &lt;- sort(featureScore(res_BREAST), decreasing = T)[1:s]

# Filter the mutations matrix based on scores
index &lt;- c()
for (i in 1:length(mutations_topscore_BREAST)) {
  tmp &lt;- grep(paste0("^", names(mutations_topscore_BREAST[i]), "$"), row.names(mutations))
  if(length(tmp)&gt;1) cat(paste0(tmp, " "))
  index &lt;- c(index, tmp)
}

mutations.filtered_BREAST &lt;- mutations[index, grep("_BREAST", colnames(mutations))]
</code></pre></div></div>

<h1 id="final-data--model-information">Final Data &amp; Model Information</h1>

<p>Let’s inspect the data. Besides the target data, already shown in the
first chapter, now three tumor-targeted matrices have been created with
a reduced and relevant number of mutations. For example, this is the
matrix for Breast cancer, with 10 specific mutations, taken randomly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutations.filtered_BREAST[1:10,1:5]

##              HCC2157_BREAST HS739T_BREAST HCC38_BREAST DU4475_BREAST MDAMB175VII_BREAST
## PDCD6_AMP                 0             0            0             0                  0
## EXOC3_AMP                 0             0            0             0                  0
## C5orf55_AMP               0             0            0             0                  0
## PP7080_AMP                0             0            0             0                  0
## AHRR_AMP                  0             0            0             0                  0
## SLC9A3_AMP                0             0            0             0                  0
## PLEKHG4B_AMP              0             0            0             0                  0
## LRRC14B_AMP               0             0            0             0                  0
## MIR4456_AMP               0             0            0             0                  0
## TPPP_AMP                  0             0            0             0                  0

sample(names(mutations_topscore_BREAST), 10)

##  [1] "TTC22_DEL"        "LOC100129924_DEL" "PPP1R14B_DEL"     "ADAMTS12_AMP"     "LDLRAD1_DEL"      "LSP1P3_AMP"       "TCEANC2_DEL"
##  [8] "TC2N_AMP"         "HEATR8-TTC4_DEL"  "LINC00466_DEL"
</code></pre></div></div>

<p>Now that the mutation matrix has been reduced in size by considering
both the most relevant mutations and the single cancer, it is possible
to train and test a model able to predict the effect of a drug on a
patient based on the cancer type and his mutational landscape.</p>

<h2 id="lung-cancer-analysis">Lung Cancer Analysis</h2>

<p>First thing is assemble the matrix for the model to be built on. One
fundamental step is to consider only common cell lines, present both in
the mutation and the target data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutL &lt;- mutations.filtered_LUNG

# Filtering out LUNG from data
targetL &lt;- target[, grep("_LUNG", colnames(target))]

target.common &lt;- targetL[, which(colnames(targetL) %in% colnames(mutL))]
mutations.common &lt;- mutL[, which(colnames(mutL) %in% colnames(targetL))]
target.common &lt;- t(target.common[, order(colnames(target.common))])
mutations.common &lt;- t(mutations.common[, order(colnames(mutations.common))])

drug_names &lt;- rownames(target)
</code></pre></div></div>

<p>The following step consists of creating a list of matrices, one for each
single drug, having the <em>response variable y</em> to be predicted as the
drug effectiveness. The mutation landscape for each cell line plays the
role of <em>predictors</em>. For example…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Creating the matrices with the response y for the single drug
tm.list &lt;- list()

for (i in 1:length(drug_names)) {
  tmp &lt;- cbind(target.common[,i], mutations.common)
colnames(tmp)[1] &lt;- "drug"
  tmp &lt;- tmp[-which(is.na(tmp[,1])), ] # remove cell lines with NaN on drug response
  tmp &lt;- tmp[-which(rowSums(tmp[,-1]) == 0), ]
  tm.list[[i]] &lt;- as.data.frame(tmp)
  rm(tmp)
}

names(tm.list) &lt;- row.names(targetL)

tm.list[[1]][1:10,1:5]

##                   drug ZNF197_DEL ZNF501_DEL TCAIM_DEL ZNF660_DEL
## ABC1_LUNG    0.6937080          0          0         0          0
## BEN_LUNG     0.9529593          1          1         1          1
## CALU3_LUNG   0.8237809          0          0         0          0
## CHAGOK1_LUNG 0.6811019          1          1         1          1
## COLO668_LUNG 0.8997014          0          0         0          0
## CORL105_LUNG 0.7064098          1          1         1          1
## CORL95_LUNG  0.9313234          0          0         0          0
## CPCN_LUNG    0.7310353          1          1         1          1
## DMS114_LUNG  0.6837069          0          0         0          0
## DMS273_LUNG  0.4735742          0          0         0          0

#names(tm.list)[1]
</code></pre></div></div>

<p>The data are prepared as usual subdividing each matrix into training and
test set.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Set the formula
f &lt;- as.formula("drug ~ .")

# Prepare Training &amp; Test set
train_frac &lt;- 0.8
train_set &lt;- list()
test_set &lt;- list()
for (i in 1:length(drug_names)) {
  data &lt;- tm.list[[i]]
  index &lt;- sample(1:nrow(data), round(train_frac*nrow(data)))
  train_set[[i]] &lt;- data[index,]
  test_set[[i]] &lt;- data[-index,]
}
</code></pre></div></div>

<p>Two different model types are built and compared in terms of
performance: a Generalized Linear Model and a Neural Network.</p>

<p>Let’s have a look at the GLM first. A simple cross-validation control is
applied in order to obtain a model whose performance is realistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MSE.glm_LUNG &lt;- c()
glm.models_LUNG &lt;-list()
response.glm_LUNG &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

glm.fit &lt;- caret::train(form = f,
                          data      = train,
                          trControl = trainControl(method = "cv", number = 10),
                          method    = "glm",
family    = gaussian()
  )
  glm.models_LUNG[[i]] &lt;- glm.fit
  pr.glm &lt;- predict(glm.fit,test)
  response.glm_LUNG[[i]] &lt;- pr.glm
  MSE.glm_LUNG[i] &lt;- sum((pr.glm - test$drug)^2)/nrow(test)
}
names(MSE.glm_LUNG) &lt;- drug_names
names(response.glm_LUNG) &lt;- drug_names
</code></pre></div></div>

<p>The NN instead underwent a refinement processe. The number of hidden
layers has always been kept to three, but the number of nodes has been
selected after various attempts. First a simple model was chosen with a
5-5-5 layout, giving decent results; the high number of predictors may
have suggested the use of a more complex model, such a 15-15-15 layout:
the prediction error increased consistently. The model proposed below
uses a 15-10-5 cascade-like layout, averaging the best performance error
over the whole bunch of drugs analyzed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MSE.nn_LUNG &lt;- c()
nn.models_LUNG &lt;- list()
response.nn_LUNG &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

nn.fit &lt;- caret::train(form = f,
                         data      = train,
                         trControl = trainControl(method = "none"),
                         method    = "neuralnet",
                         linear.output = TRUE,
                         tuneGrid = expand.grid(
                           layer1 = 15,
                           layer2 = 10,
                           layer3 = 5),
                         metric = "RMSE"
  )
  nn.models_LUNG[[i]] &lt;- nn.fit
  pr.nn &lt;- predict(nn.fit, test)
  response.nn_LUNG[[i]] &lt;- pr.nn
  MSE.nn_LUNG[i] &lt;- sum((pr.nn - test$drug)^2)/nrow(test)
}
names(MSE.nn_LUNG) &lt;- drug_names
names(response.nn_LUNG) &lt;- drug_names
</code></pre></div></div>

<p>Let’s compare the performance of these two different model approaches:
the Neural Network seems to fit better the data, averaging a lower mean
squared error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#mean(MSE.glm_LUNG)
#mean(MSE.nn_LUNG)

par(mfrow=c(1,2))
plot(MSE.glm_LUNG, type="l", col="blue", main="GLM", ylim = c(0,0.5), xlab="drugs", ylab="error")
abline(h=mean(MSE.glm_LUNG), col="red")
plot(MSE.nn_LUNG, type="l", col="blue", main="Neural Network", ylim = c(0,0.5), xlab="drugs", ylab="error")
abline(h=mean(MSE.nn_LUNG), col="red")
</code></pre></div></div>

<p><img src="project_work_files/figure-markdown_strict/unnamed-chunk-17-1.png" alt=""></p>

<p>And in a boxplot flavor…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>par(mfrow=c(1,2))
boxplot(MSE.glm_LUNG)
boxplot(MSE.nn_LUNG)
</code></pre></div></div>

<p><img src="project_work_files/figure-markdown_strict/unnamed-chunk-18-1.png" alt=""></p>

<h2 id="hlt-cancer-analysis">HLT Cancer Analysis</h2>

<p>This and the next section will be just presented in terms of code: only
the results will be discussed, as the algorithm being used is the same.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutH &lt;- mutations.filtered_HLT

# Filtering out HLT from data
targetH &lt;- target[, grep("_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE", colnames(target))]

target.common &lt;- targetH[, which(colnames(targetH) %in% colnames(mutH))]
mutations.common &lt;- mutH[, which(colnames(mutH) %in% colnames(targetH))]
target.common &lt;- t(target.common[, order(colnames(target.common))])
mutations.common &lt;- t(mutations.common[, order(colnames(mutations.common))])

drug_names &lt;- rownames(target)

# Creating the matrices with the response y for the single drug
tm.list &lt;- list()

for (i in 1:length(drug_names)) {
  tmp &lt;- cbind(target.common[,i], mutations.common)
colnames(tmp)[1] &lt;- "drug"
  tmp &lt;- tmp[-which(is.na(tmp[,1])), ] # remove cell lines with NaN on drug response
  tmp &lt;- tmp[-which(rowSums(tmp[,-1]) == 0), ]
  tm.list[[i]] &lt;- as.data.frame(tmp)
  rm(tmp)
}

names(tm.list) &lt;- row.names(targetH)

tm.list[[1]][1:10,1:5]

##                                                    drug MIR1253_DEL SMYD4_DEL OVCA2_DEL RTN4RL1_DEL
## ALLSIL_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE    0.62925057           1         1         1           1
## AMO1_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE      0.69460228           0         0         0           0
## BL41_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE      0.62164778           1         1         1           1
## CMK_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE       0.66966436           1         1         1           1
## DEL_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE       0.75351781           0         0         0           0
## DND41_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE     0.58472259           0         0         0           0
## EM2_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE       0.60183747           1         1         1           1
## EOL1_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE      0.02374275           0         0         0           0
## GA10_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE      0.75515648           0         0         0           0
## GRANTA519_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE 0.79612871           1         1         1           1

#names(tm.list)[1]

f &lt;- as.formula("drug ~ .")

# Training &amp; Test set
train_frac &lt;- 0.8
train_set &lt;- list()
test_set &lt;- list()
for (i in 1:length(drug_names)) {
  data &lt;- tm.list[[i]]
  index &lt;- sample(1:nrow(data), round(train_frac*nrow(data)))
  train_set[[i]] &lt;- data[index,]
  test_set[[i]] &lt;- data[-index,]
}

# GLM
MSE.glm_HLT &lt;- c()
glm.models_HLT &lt;-list()
response.glm_HLT &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

glm.fit &lt;- caret::train(form = f,
                          data      = train,
                          trControl = trainControl(method = "cv", number = 10),
                          method    = "glm",
family    = gaussian()
  )
  glm.models_HLT[[i]] &lt;- glm.fit
  pr.glm &lt;- predict(glm.fit,test)
  response.glm_HLT[[i]] &lt;- pr.glm
  MSE.glm_HLT[i] &lt;- sum((pr.glm - test$drug)^2)/nrow(test)
}
names(MSE.glm_HLT) &lt;- drug_names
names(response.glm_HLT) &lt;- drug_names

# NN
MSE.nn_HLT &lt;- c()
nn.models_HLT &lt;- list()
response.nn_HLT &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

nn.fit &lt;- caret::train(form = f,
                         data      = train,
                         trControl = trainControl(method = "none"),
                         method    = "neuralnet",
                         linear.output = TRUE,
                         tuneGrid = expand.grid(
                           layer1 = 15,
                           layer2 = 10,
                           layer3 = 5),
                         metric = "RMSE"
  )
  nn.models_HLT[[i]] &lt;- nn.fit
  pr.nn &lt;- predict(nn.fit, test)
  response.nn_HLT[[i]] &lt;- pr.nn
  MSE.nn_HLT[i] &lt;- sum((pr.nn - test$drug)^2)/nrow(test)
}
names(MSE.nn_HLT) &lt;- drug_names
names(response.nn_HLT) &lt;- drug_names
</code></pre></div></div>

<h2 id="breast-cancer-analysis">Breast Cancer Analysis</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutB &lt;- mutations.filtered_BREAST

# Filtering out BREAST from data
targetB &lt;- target[, grep("_BREAST", colnames(target))]

target.common &lt;- targetB[, which(colnames(targetB) %in% colnames(mutB))]
mutations.common &lt;- mutB[, which(colnames(mutB) %in% colnames(targetB))]
target.common &lt;- t(target.common[, order(colnames(target.common))])
mutations.common &lt;- t(mutations.common[, order(colnames(mutations.common))])

drug_names &lt;- rownames(target)

# Creating the matrices with the response y for the single drug
tm.list &lt;- list()

for (i in 1:length(drug_names)) {
  tmp &lt;- cbind(target.common[,i], mutations.common)
colnames(tmp)[1] &lt;- "drug"
  tmp &lt;- tmp[-which(is.na(tmp[,1])), ] # remove cell lines with NaN on drug response
  tmp &lt;- tmp[-which(rowSums(tmp[,-1]) == 0), ]
  tm.list[[i]] &lt;- as.data.frame(tmp)
  rm(tmp)
}

names(tm.list) &lt;- row.names(targetB)

tm.list[[1]][1:10,1:5]

##                     drug PDCD6_AMP EXOC3_AMP C5orf55_AMP PP7080_AMP
## BT20_BREAST    0.7200960         1         1           1          1
## BT474_BREAST   0.7017970         1         1           1          1
## CAL120_BREAST  0.5741549         1         1           1          1
## CAL51_BREAST   0.5353245         0         0           0          0
## CAL851_BREAST  0.6662680         1         1           1          1
## CAMA1_BREAST   0.8345755         0         0           0          0
## EFM19_BREAST   0.7937339         0         0           0          0
## EFM192A_BREAST 0.7805405         0         0           0          0
## EVSAT_BREAST   0.7471169         0         0           0          0
## HCC1143_BREAST 0.7371067         1         1           1          1

#names(tm.list)[1]

f &lt;- as.formula("drug ~ .")

# Training &amp; Test set
train_frac &lt;- 0.8
train_set &lt;- list()
test_set &lt;- list()
for (i in 1:length(drug_names)) {
  data &lt;- tm.list[[i]]
  index &lt;- sample(1:nrow(data), round(train_frac*nrow(data)))
  train_set[[i]] &lt;- data[index,]
  test_set[[i]] &lt;- data[-index,]
}

# GLM
MSE.glm_BREAST &lt;- c()
glm.models_BREAST &lt;-list()
response.glm_BREAST &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

glm.fit &lt;- caret::train(form = f,
                          data      = train,
                          trControl = trainControl(method = "cv", number = 10),
                          method    = "glm",
family    = gaussian()
  )
  glm.models_BREAST[[i]] &lt;- glm.fit
  pr.glm &lt;- predict(glm.fit,test)
  response.glm_BREAST[[i]] &lt;- pr.glm
  MSE.glm_BREAST[i] &lt;- sum((pr.glm - test$drug)^2)/nrow(test)
}
names(MSE.glm_BREAST) &lt;- drug_names
names(response.glm_BREAST) &lt;- drug_names

# NN
MSE.nn_BREAST &lt;- c()
nn.models_BREAST &lt;- list()
response.nn_BREAST &lt;- list()
for (i in 1:length(drug_names)) {
  train &lt;- train_set[[i]]
  test &lt;- test_set[[i]]

nn.fit &lt;- caret::train(form = f,
                         data      = train,
                         trControl = trainControl(method = "none"),
                         method    = "neuralnet",
                         linear.output = TRUE,
                         tuneGrid = expand.grid(
                           layer1 = 15,
                           layer2 = 10,
                           layer3 = 5),
                         metric = "RMSE"
  )
  nn.models_BREAST[[i]] &lt;- nn.fit
  pr.nn &lt;- predict(nn.fit, test)
  response.nn_BREAST[[i]] &lt;- pr.nn
  MSE.nn_BREAST[i] &lt;- sum((pr.nn - test$drug)^2)/nrow(test)
}
names(MSE.nn_BREAST) &lt;- drug_names
names(response.nn_BREAST) &lt;- drug_names
</code></pre></div></div>

<h2 id="results">Results</h2>

<p>It is worth comparing the performance of the models applied to the three
selected cancer types.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mean_errors &lt;- sapply(list(MSE.glm_LUNG, MSE.nn_LUNG, MSE.glm_HLT, MSE.nn_HLT, MSE.glm_BREAST, MSE.nn_BREAST), mean)

model &lt;- rep(c("GLM", "NN"), 3)
tumor &lt;- c(rep("LUNG", 2), rep("HLT", 2), rep("BREAST", 2))
performance &lt;- data.frame(model, tumor, mean_errors)

ggplot(performance, aes(fill=model, y=mean_errors, x=tumor)) +
       geom_bar(position="dodge", stat="identity")
</code></pre></div></div>

<p><img src="project_work_files/figure-markdown_strict/unnamed-chunk-23-1.png" alt=""></p>

<p>The model performance is consistent among different cancer types: the
neural network approach offers the lowest error. Surprisingly, Breast
cancer data give a better performance than HLT, even though the number
of involved cell lines is significantly lower: hence, the model is
robust and independent from the mass of data available. This is an
important feature, especially in cancer research, since data may be
partly missing and/or scarce.</p>
</body></html>
